#ifndef RAC_H_INCLUDED
#define RAC_H_INCLUDED
#include <stdio.h>
#include <stdlib.h>
/// M : N / ρ --> 110 / 0,86 --> M = 127
#define MRAC 127


  typedef struct {
    int DNI;
    char nombreyapellido[80];
    char servicios[120];
    char domicilio[80];
    char correo[50];
    char telefono[30];
    }PrestadorRAC;
   typedef struct {
   char estado;
   PrestadorRAC prestador;
  } CeldaRAC;
  typedef struct{
   CeldaRAC celda[MRAC];
   int cant;
  } RAC;

     int CantElem=0;

     int hashing_RAC (int dni) {
     char x[10];
     int longitud , i ;
     int contador=0;
     sprintf(x,"%d" , dni );
     longitud=strlen(x);
     for (i=0; i< longitud; i++)
     contador+=((int)x[i]) * (i+1);
      return (contador % MRAC);
    }
    void init_RAC(RAC *tabla){
     int i;
    for(i=0; i<MRAC; i++){
    tabla->celda[i].estado = '*';///Inicializamos todas las celdas como virgenes
  }
   tabla->cant = 0;
 }

  int Localizar_RAC(RAC *tabla, int dni, int *pos, int *costo) {
    *pos = hashing(dni);
    int i = *pos;
    int aux = -1;
    int contador = 0;
    int k = 1;

    *costo = 0;

    while (contador < MRAC && tabla->celda[i].estado != '*'&&
           tabla->celda[i].prestador.DNI != dni) {


        if (tabla->celda[i].estado == '+') {
            aux = i;
        }
        // Calculamos la siguiente posición usando exploración cuadrática
        i = (i + k) % MRAC;
        k++;
        contador++;
        (*costo)++;
    }

    // Caso 1: Prestador encontrado
    if (tabla->celda[i].prestador.DNI == dni) {
        *pos = i;
        return 1;  // Encontrado
    }

    // Caso 2: No encontrado, pero se puede dar de alta
    if (tabla->celda[i].estado == '+' && aux != -1) {
       *pos = aux;
       } else {
       *pos = i;
           }

    return 0;

}
int Alta_RAC(RAC *tabla, PrestadorRAC prestador, int *costo) {
    int pos = 0;
    int resultado = Localizar_RAC(tabla, prestador.DNI, &pos, costo);

    if (tabla->cant >= MRAC) {
        return -1;  // No hay espacio disponible
    }

    if (resultado == 1) {
        return 0;  // Fallo en el alta: el prestador ya existe
    } else {
        // Insertamos el prestador en la posición encontrada
        tabla->celda[pos].prestador = prestador;
        tabla->celda[pos].estado = 'O';  // Marcamos la celda como ocupada
        tabla->cant++;
        return 1;  // Alta exitosa
    }
}


 int Baja_RAC(RAC *tabla, int dni, int *costo) {
    int pos = 0;
    int encontrado = Localizar_RAC(tabla, dni, &pos, costo);

    if (tabla->cant == 0) {
        return -1;
    }

    if (encontrado == 0) {
        return 0;
    }


    tabla->celda[pos].estado = '+';
    tabla->cant--;
    return 1;  // Baja exitosa
}

 int Evocar_RAC(RAC *tabla, int dni, int *costo) {
    int pos = 0, pos_h = hashing_RAC(dni);  // Posición original según hash
    int encontrado = Localizar_RAC(tabla, dni, &pos, costo);

    if (tabla->cant == 0) {

        return -1;  // Estructura vacía
    }

    if (encontrado == 0) {

        return 0;  // Evocación no exitosa
    }


    return 1;  // Evocación exitosa
}
void MostrarEstructura_RAC(RAC *tabla) {
    int counta = 0;  // Contador para la paginación
    int i;
    char cont;

    for (i = 0; i < MRAC; i++) {
        // Mostrar estado de la celda
        if (tabla->celda[i].estado == '*') {
            printf("Celda %d: Virgen (nunca usada)\n", i);
        } else if (tabla->celda[i].estado == '+') {
            printf("Celda %d: Libre (usada previamente)\n", i);
        } else if (tabla->celda[i].estado == 'O') {
            // Mostrar datos del prestador en celdas ocupadas
            PrestadorRAC p = tabla->celda[i].prestador;
            printf("Celda %d: Ocupada\n", i);
            printf("  DNI: %d\n", p.DNI);
            printf("  Nombre: %s\n", p.nombreyapellido);
            printf("  Servicios: %s\n", p.servicios);
            printf("  Domicilio: %s\n", p.domicilio);
            printf("  Correo: %s\n", p.correo);
            printf("  Telefono: %s\n", p.telefono);
        }

        // Paginación
        counta++;
        if (counta % 5 == 0) {
            printf("\nPresione 's' para continuar o cualquier otra tecla para salir...\n");
            scanf(" %c", &cont);  // Usa scanf para capturar correctamente la entrada
            if (cont != 's' && cont != 'S') {
                break;  // Terminar la visualización si no se presiona 's'
            }
        }
    }
}










#endif // RAC_H_INCLUDED
