
#include <stdio.h>
#include <stdlib.h>
#include "RS.h"
#include "RAC.h"
#include "RAL.h"

int lectura_operaciones(Prestador RAL[], RAC *tablaRAC, RS *tablaRS) {
    Prestador aux;
    PrestadorRAC auxRAC;
    PrestadorRS auxRS;
    RAL_inicializar(RAL);
    init_RAC(tablaRAC);
    init_RS(tablaRS);

    int opcion = 0, exito, pos;
    int costo = 0;
    int DNI;

    FILE *fp = fopen("Operaciones-Prestadores.txt", "r");
    if (fp == NULL) {
        printf("No se puede abrir el archivo\n");
        return 0;
    }

    while (!feof(fp)) {
        fscanf(fp, "%d", &opcion);
        fscanf(fp, "%d", &aux.DNI);

        if (opcion == 1 || opcion == 2) {
            fscanf(fp, " %[^\n]", aux.nombreyapellido);
            fscanf(fp, " %[^\n]", aux.servicios);
            fscanf(fp, " %[^\n]", aux.domicilio);
            fscanf(fp, " %[^\n]", aux.correo);
            fscanf(fp, " %[^\n]", aux.telefono);

            // Copiar los datos de 'aux' a 'auxRAC' para RAC
            auxRAC.DNI = aux.DNI;
            strcpy(auxRAC.nombreyapellido, aux.nombreyapellido);
            strcpy(auxRAC.servicios, aux.servicios);
            strcpy(auxRAC.domicilio, aux.domicilio);
            strcpy(auxRAC.correo, aux.correo);
            strcpy(auxRAC.telefono, aux.telefono);

            // Copiar también para RS
            auxRS.DNI = aux.DNI;
            strcpy(auxRS.nombreyapellido, aux.nombreyapellido);
            strcpy(auxRS.servicios, aux.servicios);
            strcpy(auxRS.domicilio, aux.domicilio);
            strcpy(auxRS.correo, aux.correo);
            strcpy(auxRS.telefono, aux.telefono);

            if (opcion == 1) {  // Alta
                if (CantElemRAL < MRAL) {
                    Alta_RAL(RAL, aux, aux.DNI, &exito, opcion);
                }
                if (CantElem < MRAC) {
                    Alta_RAC(tablaRAC, auxRAC, &costo);
                }
                Alta_RS(tablaRS, auxRS);
            } else {  // Baja
                DNI = aux.DNI;
                Baja_RAL(RAL, DNI, &exito, aux, opcion);
                Baja_RAC(tablaRAC, DNI, &costo);
                Baja_RS(tablaRS, DNI);
            }
        } else if (opcion == 3) {  // Evocar

            Evocar_RAL(RAL, &aux, aux.DNI, &exito, opcion);
            Evocar_RAC(tablaRAC, aux.DNI, &costo, &auxRAC);
             Evocar_RS(tablaRS, aux.DNI, &auxRS, &costo);
        }
    }

    fclose(fp);
    return 1;
}


int main()
{
    RS tablaRS;
    int opcion;
    Prestador RAL[MRAL];  // Ajuste de tipo de prestadores
    RAC tablaRAC;

    do {
        printf("--------------------BIENVENIDO-------------------\n");
        printf("------------------ MENU PRINCIPAL----------------\n");
        printf("1: Comparar estructuras \n");
        printf("2: Mostrar: RAL \n");
        printf("3: Mostrar: RAC \n");
        printf("4: Mostrar: RS \n");
        printf("5: Salir \n");
        printf("-------------------------------------------------\n");
        scanf("%d", &opcion);

        switch (opcion) {
            case 1:  // Lectura y comparación de operaciones
                lectura_operaciones(RAL, &tablaRAC, &tablaRS);
                // Costos RAC
                printf("___________________________________________________ \n");
                printf("Rebalse Abierto Cuadratico \n");

                if (cantEvocExitosa_RAC > 0) {
                    float promedioEvocExitosa_RAC = totalEvocExitosa_RAC / (float)cantEvocExitosa_RAC;
                    printf("Costo maximo de evocacion exitosa en RAC: %d\n", maxEvocExitosa_RAC);
                    printf("Costo medio de evocacion exitosa en RAC: %.2f\n", promedioEvocExitosa_RAC);
                } else {
                    printf("No hubo evocaciones exitosas en RAC\n");
                }

                // Costos de evocaciones no exitosas
                if (cantEvocNoExitosa_RAC > 0) {
                    float promedioEvocNoExitosa_RAC = totalEvocNoExitosa_RAC / (float)cantEvocNoExitosa_RAC;
                    printf("Costo maximo de evocacion no exitosa en RAC: %d\n", maxEvocNoExitosa_RAC);
                    printf("Costo medio de evocacion no exitosa en RAC: %.2f\n", promedioEvocNoExitosa_RAC);
                } else {
                    printf("No hubo evocaciones no exitosas en RAC\n");
                }
                  printf("___________________________________________________ \n");
                  printf("Rebalse Separado \n");
                  if (cantEvocExitosa_RS > 0) {
                   float promedioEvocExitosa_RS = totalEvocExitosa_RS / (float)cantEvocExitosa_RS;
                   printf("Costo máximo de evocación exitosa en RS: %d\n", maxEvocExitosa_RS);
                   printf("Costo medio de evocación exitosa en RS: %.2f\n", promedioEvocExitosa_RS);
                   } else {
                   printf("No hubo evocaciones exitosas en RS\n");
                   }

                if (cantEvocNoExitosa_RS > 0) {
                 float promedioEvocNoExitosa_RS = totalEvocNoExitosa_RS / (float)cantEvocNoExitosa_RS;
                 printf("Costo máximo de evocación no exitosa en RS: %d\n", maxEvocNoExitosa_RS);
                 printf("Costo medio de evocación no exitosa en RS: %.2f\n", promedioEvocNoExitosa_RS);
                   }  else {
                 printf("No hubo evocaciones no exitosas en RS\n");
               }

                break;

            case 2:  // Mostrar RAL
                MostrarEstructura_RAL(RAL);
                break;

            case 3:  // Mostrar RAC
                MostrarEstructura_RAC(&tablaRAC);
                break;

            case 4:  // Mostrar RS
                MostrarEstructura_RS(&tablaRS);
                break;
            case 5:
                printf("Saliendo...\n");
                break;
            default:
                printf("Error elija una opcion valida. \n");
                break;
        }
    } while (opcion != 5);
    //ANALISIS DE RESULTADOS: RAL
    //EVOCACION EXITOSA: se obtiene una media de 4, y un maximo de 121.
    //Estos valores contrastan considerablemente con los de las evocaciones no exitosas,
    //para las cuales el valor máximo es de 134 y el medio es de 107.
    //Sin embargo, estos resultados son razonables, ya que, una vez que la estructura se encuentre más llena,
    //cada evocación no exitosa analizará varias veces 134 celdas, es decir, toda la estructura.
    //Entonces, como conclusión, se puede afirmar que los valores obtenidos son razonables respecto a la estructura, y su forma de localización.
    return 0;
}
