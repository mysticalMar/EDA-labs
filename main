
#include <stdio.h>
#include <stdlib.h>
#include "RS.h"
#include "RAC.h"
#include "RAL.h"

int lectura_operaciones(Prestador RAL[], RAC *tablaRAC, RS *tablaRS) {
    Prestador aux;
    PrestadorRAC auxRAC;
    PrestadorRS auxRS;
    RAL_inicializar(RAL);
    init_RAC(tablaRAC);
    init_RS(tablaRS);

    int opcion = 0, exito, pos;
    int costo = 0;
    int DNI;

    FILE *fp = fopen("OperacionesPrestadores.txt", "r");
    if (fp == NULL) {
        printf("No se puede abrir el archivo\n");
        return 0;
    }

    while (!feof(fp)) {
        fscanf(fp, "%d", &opcion);
        fscanf(fp, "%d", &aux.DNI);

        if (opcion == 1 || opcion == 2) {
            fscanf(fp, " %[^\n]", aux.nombreyapellido);
            fscanf(fp, " %[^\n]", aux.servicios);
            fscanf(fp, " %[^\n]", aux.domicilio);
            fscanf(fp, " %[^\n]", aux.correo);
            fscanf(fp, " %[^\n]", aux.telefono);

            // Copiar los datos de 'aux' a 'auxRAC' para RAC
            auxRAC.DNI = aux.DNI;
            strcpy(auxRAC.nombreyapellido, aux.nombreyapellido);
            strcpy(auxRAC.servicios, aux.servicios);
            strcpy(auxRAC.domicilio, aux.domicilio);
            strcpy(auxRAC.correo, aux.correo);
            strcpy(auxRAC.telefono, aux.telefono);

            // Copiar también para RS
            auxRS.DNI = aux.DNI;
            strcpy(auxRS.nombreyapellido, aux.nombreyapellido);
            strcpy(auxRS.servicios, aux.servicios);
            strcpy(auxRS.domicilio, aux.domicilio);
            strcpy(auxRS.correo, aux.correo);
            strcpy(auxRS.telefono, aux.telefono);

            if (opcion == 1) {  // Alta
                if (CantElemRAL < MRAL) {
                    Alta_RAL(RAL, aux, aux.DNI, &exito, opcion);
                }
                if (CantElem<MRAC){
                    Alta_RAC(tablaRAC, auxRAC, &costo);
                }

                    Alta_RS(tablaRS, auxRS);  // Insertamos 'auxRS' en la estructura RS
            } else {  // Baja
                DNI = aux.DNI;
                Baja_RAL(RAL, DNI, &exito, aux, opcion);
                Baja_RAC(tablaRAC, DNI, &costo);
                Baja_RS(tablaRS, DNI);
            }
        } else if (opcion == 3) {  // Evocar
            Evocar_RAL(RAL, &aux, aux.DNI, &exito, costo);
            Evocar_RAC(tablaRAC, aux.DNI, &costo);
            Evocar_RS(tablaRS, aux.DNI, &costo);
        }
    }

    fclose(fp);
    return 1;
}


int main()
{
    RS tablaRS;
    int opcion;
    Prestador RAL[MRAL];  // Ajuste de tipo de prestadores
    RAC tablaRAC;

    do {
        printf("--------------------BIENVENIDO-------------------\n");
        printf("------------------ MENU PRINCIPAL----------------\n");
        printf("1: Comparar estructuras \n");
        printf("2: Mostrar: RAL \n");
        printf("3: Mostrar: RAC \n");
        printf("4: Mostrar: RS \n");
        printf("5: Salir \n");
        printf("-------------------------------------------------\n");
        scanf("%d", &opcion);

        switch (opcion) {
            case 1:  // Lectura y comparación de operaciones
                lectura_operaciones(RAL, &tablaRAC, &tablaRS);



                // Costos RAL
                printf("________________________Costos_________________________________\n");
                printf("Rebalse Abierto Lineal \n");
                // Costos de evocaciones exitosas
                  printf("Maximo de evocacion exitosa: %d \n", RAL_max_E);
               if (RAL_evocar_E>0){
                RAL_medio=RAL_t_E/RAL_evocar_E;
                printf("Medio de evocacion exitosa: %f \n", RAL_medio);
            } else printf("No hubo evocaciones exitosas \n");
            //Costos de evocaciones no exitosas
            printf("Maximo de evocacion no exitosa: %d \n", RAL_max_F);
            if (RAL_evocar_F>0){
                RAL_medio=RAL_t_F/RAL_evocar_F;
                printf("Medio de evocacion no exitosa: %f \n", RAL_medio);
            } else printf("No hubo evocaciones no exitosas \n");

                // Costos RAC
                printf("___________________________________________________ \n");
                printf("Rebalse Abierto Cuadratico \n");

                if (cantEvocExitosa_RAC > 0) {
                    float promedioEvocExitosa_RAC = totalEvocExitosa_RAC / (float)cantEvocExitosa_RAC;
                    printf("Costo maximo de evocacion exitosa en RAC: %d\n", maxEvocExitosa_RAC);
                    printf("Costo medio de evocacion exitosa en RAC: %.2f\n", promedioEvocExitosa_RAC);
                } else {
                    printf("No hubo evocaciones exitosas en RAC\n");
                }

                // Costos de evocaciones no exitosas
                if (cantEvocNoExitosa_RAC > 0) {
                    float promedioEvocNoExitosa_RAC = totalEvocNoExitosa_RAC / (float)cantEvocNoExitosa_RAC;
                    printf("Costo maximo de evocacion no exitosa en RAC: %d\n", maxEvocNoExitosa_RAC);
                    printf("Costo medio de evocacion no exitosa en RAC: %.2f\n", promedioEvocNoExitosa_RAC);
                } else {
                    printf("No hubo evocaciones no exitosas en RAC\n");
                }


                //Costos RS
                printf("___________________________________________________ \n");
                printf("Rebalse Separado \n");
                // Costos de evocaciones exitosas
                if (cantEvocExitosa_RS > 0) {
                    float promedioEvocExitosa_RS = totalEvocExitosa_RS / (float)cantEvocExitosa_RS;
                    printf("Costo maximo de evocacion exitosa en RS: %d\n", maxEvocExitosa_RS);
                    printf("Costo medio de evocacion exitosa en RS: %.2f\n", promedioEvocExitosa_RS);
                } else {
                    printf("No hubo evocaciones exitosas en RS\n");
                }

                // Costos de evocaciones no exitosas
                if (cantEvocNoExitosa_RS > 0) {
                    float promedioEvocNoExitosa_RS = totalEvocNoExitosa_RS / (float)cantEvocNoExitosa_RS;
                    printf("Costo maximo de evocacion no exitosa en RS: %d\n", maxEvocNoExitosa_RS);
                    printf("Costo medio de evocacion no exitosa en RS: %.2f\n", promedioEvocNoExitosa_RS);
                } else {
                    printf("No hubo evocaciones no exitosas en RS\n");
                }

                      printf("___________________________________________________ \n");
                      printf("Analisis de resultados \n");
                      printf("Rebalse Abierto Lineal \n");
                      printf("Evocacion exitosa: el peor caso en el rebalse abierto lineal es examinar 133 baldes. El maximo obtenido en esta ejecucion fue de: %d \n", RAL_max_E);
                      printf("Evocacion no exitosa: el peor caso en el rebalse abierto lineal es examinar 134 baldes. El maximo obtenido en esta ejecucion fue de: %d \n", RAL_max_F);
                       printf("___________________________________________________ \n");
                       printf("Rebalse Abierto Cuadratico \n");
                       printf("Evocacion exitosa: El peor caso en el rebalse abierto cuadratico es examinar 127 baldes. El maximo obtenido en esta ejecucion fue de: %d \n", maxEvocExitosa_RAC);
                       printf("Evocacion exitosa: El peor caso en el rebalse abierto cuadratico es examinar 128 baldes. El maximo obtenido en esta ejecucion fue de: %d \n", maxEvocNoExitosa_RAC);
                       printf("___________________________________________________ \n");
                       printf("Rebalse Separado \n");
                       printf("Evocacion exitosa: el peor caso en el rebalse separado es examinar 67 baldes. El maximo obtenido en esta ejecucion fue de: %d \n", maxEvocExitosa_RS);
                       printf("Evocacion no exitosa: el peor caso en el rebalse separado es examinar 68 baldes. El maximo obtenido en esta ejecucion fue de: %d \n", maxEvocNoExitosa_RS);
                       printf("___________________________________________________ \n");
                        printf("Como conclusion, podemos observar que la estructura mas eficiente a la hora de evocar un elemento es el Rebalse Separado, teniendo los menores costos maximos y medios. \n");


                break;

            case 2:  // Mostrar RAL
                MostrarEstructura_RAL(RAL);
                break;

            case 3:  // Mostrar RAC
                MostrarEstructura_RAC(&tablaRAC);
                break;

            case 4:  // Mostrar RS
                MostrarEstructura_RS(&tablaRS);
                break;
            case 5:
                printf("Saliendo...\n");
                break;
            default:
                printf("Error elija una opcion valida. \n");
                break;
        }
    } while (opcion != 5);

    return 0;
}
