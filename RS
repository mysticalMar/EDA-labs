#ifndef RS_H_INCLUDED
#define RS_H_INCLUDED

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAXPRESTADORES 110
#define PAUSA_PRESTADORES 5
#define PRE_RS 64 // MRS
///Varibles globales de costo
int maxEvocExitosa_RS = 0, maxEvocNoExitosa_RS = 0;
int totalEvocExitosa_RS = 0, totalEvocNoExitosa_RS = 0;
int cantEvocExitosa_RS = 0, cantEvocNoExitosa_RS = 0;




typedef struct {
    int DNI;
    char nombreyapellido[80];
    char servicios[120];
    char domicilio[80];
    char correo[50];
    char telefono[30];
} PrestadorRS;

typedef struct celdaRS {
    PrestadorRS datos; // Prestador de cabecera
    struct celdaRS *psig;
} CeldaRS;

typedef struct RS{
    CeldaRS a[PRE_RS];
    CeldaRS *anterior;
    CeldaRS *actual;
    int cant;
}RS;

// Función hashing para calcular la posición
int hashing_RS(int dni, int M) {
    char x[10];
    int longitud, i;
    int contador = 0;
    sprintf(x, "%d", dni);
    longitud = strlen(x);
    for (i = 0; i < longitud; i++)
        contador += ((int)x[i]) * (i + 1);
    return (contador % M);
}

// Inicializar la estructura RS
void init_RS(RS *tabla) {
    int i;
    tabla->cant = 0;
    for (i = 0; i < PRE_RS; i++) {
        tabla->a[i].psig = NULL;
    }
    tabla->actual = NULL;
    tabla->anterior = NULL;
}

// Crear una nueva celda para la lista enlazada
CeldaRS* nuevacelda(PrestadorRS prestador) {
    CeldaRS *nuevo = (CeldaRS*)malloc(sizeof(CeldaRS));
    if (nuevo == NULL) return NULL;
    nuevo->datos = prestador;
    nuevo->psig = NULL;
    return nuevo;
}

int Localizar_RS(RS *tabla, int DNI, CeldaRS **resultado, int *costo) {
    int pos = hashing_RS(DNI, PRE_RS);
    int c = 0;
    CeldaRS *actual = tabla->a[pos].psig;
    while (actual != NULL) {
        c++;  // Cada consulta a un nodo aumenta el costo
        if (actual->datos.DNI == DNI) {
            *resultado = actual;
            *costo = c;
            return 1;  // Evocación exitosa
        }
        tabla->anterior = actual;
        actual = actual->psig;
    }
    *costo = c;
    return 0;  // No se encontró el DNI
}


int Alta_RS(RS *tabla, PrestadorRS prestador) {
    CeldaRS *existe = NULL;
    int costo = 0, pos = 0;

    int encontrado = Localizar_RS(tabla, prestador.DNI, &existe, &costo);

    if (encontrado) {
        return 0;  // Prestador duplicado
    }

    if (tabla->a[pos].datos.DNI == 0) {
        // Insertar en la cabecera si está vacía
        tabla->a[pos].datos = prestador;
    } else {
        // Insertar en la lista de colisiones
        CeldaRS *nuevo = nuevacelda(prestador);
        if (!nuevo) return -1; // Error de memoria
        nuevo->psig = tabla->a[pos].psig;
        tabla->a[pos].psig = nuevo;
    }

    tabla->cant = tabla->cant +1;
    return 1;  // Alta exitosa
}

int Baja_RS(RS *tabla, int DNI) {
    CeldaRS *existe = NULL;
    int costo = 0, pos = 0;

    int encontrado = Localizar_RS(tabla, DNI, &existe, &costo);

    if (!encontrado) {
        return 0;  // Baja no exitosa
    }

    // Verificar si el prestador está en la cabecera
    if (&tabla->a[pos] == existe) {
        if (tabla->a[pos].psig) {
            CeldaRS *temp = tabla->a[pos].psig;
            tabla->a[pos].datos = temp->datos;
            tabla->a[pos].psig = temp->psig;
            free((void *)temp);
        } else {
            tabla->a[pos].datos.DNI = 0; // Marca la cabecera como vacía
        }
    } else {
        tabla->anterior->psig = existe->psig;
        free((void *)existe);
    }

    tabla->cant = tabla->cant-1;
    return 1;  // Baja exitosa
}

    void Evocar_RS(RS *tabla, int DNI, PrestadorRS *resultado, int *costo, int *exito) {
    CeldaRS *prestador = NULL;
    *costo = 1;  // Comienza el conteo del costo con el primer balde consultado

    *exito = Localizar_RS(tabla, DNI, &prestador, costo);

    if (*exito == 1) {
        // Evocación exitosa
        *resultado = prestador->datos;  // Devolver la tupla completa
        totalEvocExitosa_RS += *costo;
        cantEvocExitosa_RS++;

        if (*costo > maxEvocExitosa_RS) {
            maxEvocExitosa_RS = *costo;
        }
    } else {
        // Evocación no exitosa
        *exito = 0;
        totalEvocNoExitosa_RS += *costo;
        cantEvocNoExitosa_RS++;

        if (*costo > maxEvocNoExitosa_RS) {
            maxEvocNoExitosa_RS = *costo;
        }
    }
}


void MostrarPrestador(PrestadorRS p) {
    printf("--------- Listado de Prestadores ---------\n");

    printf("DNI: %d\n", p.DNI);
    printf("Nombre y Apellido: %s\n", p.nombreyapellido);
    printf("Servicios: %s\n", p.servicios);
    printf("Domicilio: %s\n", p.domicilio);
    printf("Correo: %s\n", p.correo);
    printf("Telefono: %s\n", p.telefono);
}

void MostrarEstructura_RS(RS *rs) {
    int i;
    int lista_vacia = 1;  // Bandera para verificar si la lista está vacía
    int totaldeprestadores = 0;
    int contador;

    // Verificar si hay algún prestador en la estructura
    for (i = 0; i < PRE_RS; i++) {
        if (rs->a[i].psig != NULL) {
            lista_vacia = 0;  // Si hay al menos un prestador, la lista no está vacía
            break;
        }
        if ( lista_vacia ) {
        printf("La lista de prestadores esta vacia.\n");
        getchar();
        return;
    }
    }


    // Si la lista no está vacía, mostrar los prestadores con paginación

    for (i = 0; i < PRE_RS ; i++) {
        CeldaRS *actual = rs->a[i].psig;

        printf("Posicion %d: ", i);

        if (actual == NULL) {
            printf("*VACIA*\n");

        } else {
            printf("\n");
        }

        // Mostrar todos los prestadores en esta posición
        while (actual != NULL && totaldeprestadores < MAXPRESTADORES) {
            MostrarPrestador(actual->datos);
            printf("------------------------------------------\n");
            actual = actual->psig;

         totaldeprestadores ++;

            // Pausa cada 5 prestadores
            if (contador % 5 == 0) {
                printf("Presione Enter para continuar...\n");
                getchar();  // Pausa tras cada 5 prestadores
            }
        }
    }


    // En caso de que queden menos de 5 prestadores para mostrar, hacer una pausa al final
    if (contador % 5 != 0) {
        printf("Presione Enter para volver al menú principal...\n");
        getchar();
    }
}







#endif // RS_H_INCLUDED
