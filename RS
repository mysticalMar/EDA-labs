#ifndef RS_H_INCLUDED
#define RS_H_INCLUDED

// M= 110/1.74 = 63 ---> prox primo es:67
#define PRE_RS 67

  typedef struct {
    int DNI;
    char nombreyapellido[80];
    char servicios[120];
    char domicilio[80];
    char correo[50];
    char telefono[30];
    }PrestadorRS;

   typedef struct celdaRS {
      PrestadorRS datos; /// Prestador de "cabecera" en cada balde
      struct celdaRS *psig;
   } CeldaRS;

   typedef struct {
      CeldaRS a[PRE_RS];
      CeldaRS *anterior;
      CeldaRS *actual;
      int cant;
   } RS;

    int hashing_RS(char* x,int M){
    int longitud,i;
    int contador = 0;
    longitud = strlen(x);
    for(i=0;i < longitud; i++)
        contador +=((int)x[i])*(i + 1) ;
    return (contador % M);
     }

    void init_RS(RS *tabla){
    int i;
    tabla->cant = 0;
    for(i=0; i<PRE_RS; i++){
        tabla->a[i].psig = NULL; ///Inicializamos a los punteros de cada balde como NULL
    }
    tabla->actual = NULL;
    tabla->anterior = NULL;

    }


   CeldaRS* nuevacelda(PrestadorRS prestador){
    CeldaRS *nuevo = (CeldaRS*)malloc(sizeof(CeldaRS));

    if(nuevo == NULL){
        return NULL;
    }
    nuevo->datos = prestador;
    nuevo->psig = NULL;
    return nuevo;

   }
   int Localizar_RS(RS *tabla, int DNI, CeldaRS **resultado, float *costo) {
    int pos = hashing_RS(DNI, PRE_RS);
    float c = 0;
    CeldaRS *actual = tabla->a[pos].psig;
    while (actual != NULL) {
        c++;  // Cada consulta a un nodo aumenta el costo
        if (actual->datos.DNI == DNI) {
            *resultado = actual;  // Devuelvo el nodo encontrado
            *costo = c;  // Actualizamos el costo
            return 1;  // Evocación exitosa
        }
        actual = actual->psig;
    }
    *costo = c;  // Actualizamos el costo aunque no se encuentre
    return 0;  // No se encontró el prestador
}

int Alta_RS(RS *tabla, PrestadorRS prestador, float *costo) {
    CeldaRS *existe = NULL;
    float c = 0;
    int e = Localizar_RS(tabla, prestador.DNI, &existe, &c);
    if (e == 1) {
        return 0;  // El prestador ya existe
    }

    int pos = hashing_RS(prestador.DNI, PRE_RS);
    c++;  // Consultar la posición del balde también tiene un costo
    *costo = c;

    CeldaRS *nuevo = nuevacelda(prestador);
    if (nuevo == NULL) {
        return -1;  // No hay más memoria
    }

    // Insertamos al inicio de la lista enlazada
    nuevo->psig = tabla->a[pos].psig;
    tabla->a[pos].psig = nuevo;
    tabla->cant++;
    return 1;  // Alta exitosa
}

int Baja_RS(RS *tabla, int DNI, float *costo) {
    int pos = hashing_RS(DNI, PRE_RS);
    float c = 0;
    CeldaRS *actual = tabla->a[pos].psig;
    CeldaRS *anterior = NULL;
    CeldaRS *existe = NULL;

    int e = Localizar_RS(tabla, DNI, &existe, &c);
    if (e == 0) {
        *costo = c;
        return 0;  // El prestador no existe
    }

    // Buscamos y eliminamos el prestador
    while (actual != NULL) {
        if (actual->datos.DNI == DNI) {
            if (anterior == NULL) {
                tabla->a[pos].psig = actual->psig;
            } else {
                anterior->psig = actual->psig;
            }
            free(actual);
            tabla->cant--;
            *costo = c;
            return 1;  // Baja exitosa
        }
        anterior = actual;
        actual = actual->psig;
        c++;  // Incrementamos el costo por cada nodo consultado
    }

    *costo = c;
    return 0;  // Baja no exitosa
}

void Mostrar_RS(RS *tabla) {
    int i, counta = 0;
    char seguir;
    CeldaRS *actual;

    for (i = 0; i < PRE_RS; i++) {
        printf("---------------------\n");
        printf("Balde %d:\n", i);

        ///Si esta Vacio
        if (tabla->a[i].datos.DNI == 0 && tabla->a[i].psig == NULL) {
            printf("  [VACÍO]\n");
        } else {
            actual = tabla->a[i].psig;
            while (actual != NULL) {
                printf("     DNI: %d\n", actual->datos.DNI);
                printf("     Nombre y Apellido: %s\n", actual->datos.nombreyapellido);
                printf("     Servicios: %s\n", actual->datos.servicios);
                printf("     Domicilio: %s\n", actual->datos.domicilio);
                printf("     Correo: %s\n", actual->datos.correo);
                printf("     Telefono: %s\n", actual->datos.telefono);
                actual = actual->psig;
            }
        }
        printf("---------------------\n");
        counta++;

        // Paginación: después de mostrar 5 baldes, preguntar si continuar
        if (counta % 5 == 0) {
            printf("¿Desea continuar mostrando más baldes? (s/n): ");
            scanf(" %c", &seguir);
            if (seguir == 'n' || seguir == 'N') {
                break;  // Si el usuario elige no continuar, se termina la función
            }
        }
    }
}


   int Evocar_RS(RS *tabla, int DNI, float *costo) {
    CeldaRS *prestador = NULL;
    float c;
    int e = Localizar_RS(tabla, DNI, &prestador);  // Buscar el prestador con el DNI
    *costo = c;
    if (e == 0) {
        printf("El prestador con DNI %d no se encuentra en la tabla.\n", DNI);
        return 0; // Prestador no encontrado
    }

    // Mostrar la información del prestador
    printf("Prestador encontrado:\n");
    printf("DNI: %d\n", prestador->datos.DNI);
    printf("Nombre y Apellido: %s\n", prestador->datos.nombreyapellido);
    printf("Servicios: %s\n", prestador->datos.servicios);
    printf("Domicilio: %s\n", prestador->datos.domicilio);
    printf("Correo: %s\n", prestador->datos.correo);
    printf("Telefono: %s\n", prestador->datos.telefono);
    return 1; // Evocación exitosa
}



#endif // RS_H_INCLUDED
